// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `is_valid_session_ticket`, `parse_ticket_node_addr`, `send_message_via_client`
// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `ConnectionConfig`, `NetworkConfig`, `TerminalSession`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `from`, `from`

String parseSessionTicket({required String ticket}) =>
    RustLib.instance.api.crateApiIrohClientParseSessionTicket(ticket: ticket);

Future<String> initializeNetworkWithRelay({String? relayUrl}) => RustLib
    .instance
    .api
    .crateApiIrohClientInitializeNetworkWithRelay(relayUrl: relayUrl);

Future<String> initializeNetwork() =>
    RustLib.instance.api.crateApiIrohClientInitializeNetwork();

Future<String> connectToPeer({required String sessionTicket}) => RustLib
    .instance
    .api
    .crateApiIrohClientConnectToPeer(sessionTicket: sessionTicket);

Future<void> createTerminal({required TerminalCreateRequest request}) =>
    RustLib.instance.api.crateApiIrohClientCreateTerminal(request: request);

Future<void> stopTerminal({required TerminalStopRequest request}) =>
    RustLib.instance.api.crateApiIrohClientStopTerminal(request: request);

Future<void> listTerminals({required String sessionId}) =>
    RustLib.instance.api.crateApiIrohClientListTerminals(sessionId: sessionId);

Future<void> sendTerminalInputToTerminal({
  required TerminalInputRequest request,
}) => RustLib.instance.api.crateApiIrohClientSendTerminalInputToTerminal(
  request: request,
);

Future<void> resizeTerminal({required TerminalResizeRequest request}) =>
    RustLib.instance.api.crateApiIrohClientResizeTerminal(request: request);

Future<void> disconnectSession({required String sessionId}) => RustLib
    .instance
    .api
    .crateApiIrohClientDisconnectSession(sessionId: sessionId);

Future<List<String>> getActiveSessions() =>
    RustLib.instance.api.crateApiIrohClientGetActiveSessions();

Future<String> getNodeInfo() =>
    RustLib.instance.api.crateApiIrohClientGetNodeInfo();

Future<StreamEvent> getEventStream({required String sessionId}) =>
    RustLib.instance.api.crateApiIrohClientGetEventStream(sessionId: sessionId);

class RustError implements FrbException {
  final int code;
  final String message;

  const RustError({required this.code, required this.message});

  @override
  int get hashCode => code.hashCode ^ message.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is RustError &&
          runtimeType == other.runtimeType &&
          code == other.code &&
          message == other.message;
}

class StreamEvent {
  final String sessionId;
  final String eventType;
  final String data;

  const StreamEvent({
    required this.sessionId,
    required this.eventType,
    required this.data,
  });

  @override
  int get hashCode => sessionId.hashCode ^ eventType.hashCode ^ data.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is StreamEvent &&
          runtimeType == other.runtimeType &&
          sessionId == other.sessionId &&
          eventType == other.eventType &&
          data == other.data;
}

class TerminalCreateRequest {
  final String sessionId;
  final String? name;
  final String? shellPath;
  final String? workingDir;
  final (int, int)? size;

  const TerminalCreateRequest({
    required this.sessionId,
    this.name,
    this.shellPath,
    this.workingDir,
    this.size,
  });

  @override
  int get hashCode =>
      sessionId.hashCode ^
      name.hashCode ^
      shellPath.hashCode ^
      workingDir.hashCode ^
      size.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is TerminalCreateRequest &&
          runtimeType == other.runtimeType &&
          sessionId == other.sessionId &&
          name == other.name &&
          shellPath == other.shellPath &&
          workingDir == other.workingDir &&
          size == other.size;
}

class TerminalInputRequest {
  final String sessionId;
  final String terminalId;
  final String input;

  const TerminalInputRequest({
    required this.sessionId,
    required this.terminalId,
    required this.input,
  });

  @override
  int get hashCode => sessionId.hashCode ^ terminalId.hashCode ^ input.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is TerminalInputRequest &&
          runtimeType == other.runtimeType &&
          sessionId == other.sessionId &&
          terminalId == other.terminalId &&
          input == other.input;
}

class TerminalResizeRequest {
  final String sessionId;
  final String terminalId;
  final int rows;
  final int cols;

  const TerminalResizeRequest({
    required this.sessionId,
    required this.terminalId,
    required this.rows,
    required this.cols,
  });

  @override
  int get hashCode =>
      sessionId.hashCode ^ terminalId.hashCode ^ rows.hashCode ^ cols.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is TerminalResizeRequest &&
          runtimeType == other.runtimeType &&
          sessionId == other.sessionId &&
          terminalId == other.terminalId &&
          rows == other.rows &&
          cols == other.cols;
}

class TerminalStopRequest {
  final String sessionId;
  final String terminalId;

  const TerminalStopRequest({
    required this.sessionId,
    required this.terminalId,
  });

  @override
  int get hashCode => sessionId.hashCode ^ terminalId.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is TerminalStopRequest &&
          runtimeType == other.runtimeType &&
          sessionId == other.sessionId &&
          terminalId == other.terminalId;
}
